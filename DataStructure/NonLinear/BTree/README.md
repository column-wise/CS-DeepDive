# B-Tree란?

B-Tree는 정렬된 데이터를 효율적으로 저장하고,  
검색/삽입/삭제 연산을 빠르게 처리하기 위한 균형 잡힌 다진 트리(M-ary Tree)이다.  

Binary Tree는 각 노드가 최대 2개의 자식만 가질 수 있지만,  
B-Tree는 M개까지 자식 노드를 가질 수 있어 더 많은 데이터를 넓은 구조로 다룰 수 있다.

⸻

## B-Tree의 정의 (차수 M일 때)

1.	각 노드는 최대 M개의 자식 노드를 가질 수 있다.
2.	각 노드는 최소 ⌈M/2⌉개의 자식 노드를 가져야 한다. (루트 제외)
3.	모든 리프 노드의 깊이는 동일하다.
4.	자식 노드가 N개인 노드는 항상 N-1개의 키를 가진다.
5.	루트 노드는 자식이 없어도 된다. 하지만 자식이 있다면 최소 2개 이상이어야 한다.

⸻

## B-Tree의 검색 알고리즘

1. 루트 노드에서 시작하여 각 노드의 키들을 왼쪽부터 오른쪽으로 순차 탐색.
2.	찾고자 하는 키가 존재하면 성공.
3.	존재하지 않으면, 현재 노드에서 키와 키 사이에 위치한 자식 노드로 이동.
4.	이 과정을 리프 노드에 도달할 때까지 반복한다.

B-Tree의 검색 시간은 O(log n)이다.

⸻

## B-Tree의 삽입

1.	적절한 리프 노드를 찾아 새 키를 삽입.
2.	삽입 후 해당 노드의 키 개수가 최대 허용 수 (M-1개)를 넘으면 분할(split) 수행.

### 분할 과정
•	중간 키 값을 부모 노드로 올리고,

•	왼쪽 키들과 자식은 왼쪽 자식 노드,

•	오른쪽 키들과 자식은 오른쪽 자식 노드로 분리.

⸻

## B-Tree의 삭제

B-Tree에서 키 삭제는 단순히 값 하나를 지우는 것이 아니라, 트리의 균형 유지까지 고려해야 하므로 다양한 케이스 처리가 필요하다.

⸻

### [기본 개념]

삭제하고자 하는 키 K가 존재하는 노드를 찾아서, 해당 위치와 상황에 따라 처리한다.

삭제 위치는 크게 리프 노드인지, 내부 노드인지로 나뉜다.

⸻

### 1. 리프 노드에서 삭제할 경우

리프는 자식이 없기 때문에 구조 변경 없이 바로 삭제할 수 있지만, 삭제 후 키 개수가 부족하면 복구 작업이 필요하다.

Case 1: 삭제 후에도 최소 키 수 이상 유지됨

→ 그냥 삭제

Case 2: 삭제 후 키 개수가 ⌈M/2⌉ - 1 보다 작아짐

→ 형제 또는 부모를 통해 복구 작업 필요

#### 복구 방법
•	Case 2-1: 형제 노드(좌우 중 하나)가 여유 키를 가짐  
  → 회전(Rotation)  
  → 형제의 키를 하나 가져오고, 부모의 키를 내려줌

•	Case 2-2: 형제도 최소 키만 있음 → 병합 필요  
  → 현재 노드 + 형제 노드 + 부모의 중간 키를 병합  
  → 병합 후 부모 노드의 키가 줄어들기 때문에, 부모 노드에 대해서도 재귀적으로 복구가 필요할 수 있음

⸻

### 2. 내부 노드에서 삭제할 경우

내부 노드는 자식 노드를 갖기 때문에 단순 삭제가 불가능하다.

Case 1: 삭제 대상 키 K의 양쪽 자식 중 하나라도 충분한 키 보유  
•	왼쪽 서브트리에서 가장 큰 키 (predecessor) 혹은  
•	오른쪽 서브트리에서 가장 작은 키 (successor)  
→ 이 중 하나로 대체한 뒤, 해당 값을 리프에서 삭제 (→ 리프 삭제 상황으로 연결)

Case 2: 양쪽 자식 모두 최소 키만 갖고 있음

→ 두 자식 노드 + 삭제할 키를 병합하여 하나의 노드로 만듦  
→ 부모에서 키가 사라지므로 부모도 재구조화 대상이 될 수 있음  
→ 이 작업도 재귀적으로 위로 전파됨  

⸻

#### 재구조화
1.	병합 후 부모 노드에서 키가 사라짐 → 부모의 키 수가 최소보다 적어짐  
2.	다시 형제에서 빌릴 수 있는지 확인 → 불가능하면 병합  
3.	루트까지 계속 올라가다가, 루트도 비게 되면  
→ 루트가 제거되고 병합된 노드가 새 루트가 됨  
→ 트리의 높이가 1 줄어든다
